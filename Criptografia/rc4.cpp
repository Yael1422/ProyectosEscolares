/* 
 Esta es una versi√≥n que corre en Ubuntu 7.04 con gcc 4.1.4
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))

unsigned char S[256];
unsigned int i, j, k;

//=============================================
//definimos la funcion del swap para hacer los
//cambios correspondientes en la s[x] y S[y] 
//============================================== 

void swap(unsigned char *s, unsigned int i, unsigned int j) 
{
    unsigned char temp = s[i];
    s[i] = s[j];
    s[j] = temp;
}
 
/* KSA */
void rc4_init(unsigned char *key, unsigned int key_length) 
{
    for (i = 0; i < 256; i++)
        S[i] = i;
 
    for (i = j = 0; i < 256; i++) {
        j = (j + key[i % key_length] + S[i]) & 255;
        swap(S, i, j);
    }
  
      i = j = 0;
     
}
 

/* PRGA */
unsigned char rc4_output() {
    i = (i + 1) & 255;
    j = (j + S[i]) & 255;
    int z;
    z=S[i]+S[j]&255;
    swap(S, i, j);
     
/*	  printf("\n");
      printf("\nState[clv]=%02X\n",S[j]);
      printf("\n");
    
    printf("\n\nX=%02X",i);
    printf("\nY=%02X",j);
    printf("\nS[X]=%02X",S[j]);
    printf("\nS[Y]=%02X",S[i]);
    printf("\nXorIDx=%02X",z);
    printf("\nS[XorIDx]=%02X",S[(S[i] + S[j]) & 255]);
*/	        
    
	return S[(S[i] + S[j]) & 255];
	
}
 
/*Empieza el programa principal*/
 
int main() 
{
    printf("\n");
/*    unsigned char *test_vectors[][2] = 
    {
        {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0}, {1,2,3,4,5,6,7,8,0}; : 0xEF,0xDC,0xAB,0x89,0x76,0x45,0x23,0x11
    };
 */
unsigned char key[]={0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,
                     0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0xEF,0xCD,0xAB,0x89,0x67,0x54,0x32,0x01,0};

unsigned char msg[65]={0x52, 0x65, 0x64, 0x65,0x73,0x20,0x79,0x20,0x53,0x65,0x67,0x75,0x72,0x69,0x64,0x61,0x64,0x2C,0x20,0x43,0x72,0x69,0x70,0x74,0x6F,0x67,0x72,0x61,0x66,0xED,0x61,0x20,0x41,0x70,0x6C,0x69,0x63,0x61,0x64,0x61,0x20,0x61,0x20,0x73,0x69,0x73,0x74,0x74,0x61,0x64,0x20,0x64,0x65,0x20,0x49,0x6E,0x67,0x65,0x6E,0x69,0x65,0x72,0xED,0x61,0x2E};

unsigned char decryp[92]={0x87,0xF4,0x72,0x95,0x90,0x40, 0xAB, 0xB4, 0x73, 0x07, 0x0F, 0xFF, 0xF1,0x44,0x6D,0x1B};

    int x;
   			printf("\nUsando la llave: ");
 		for (x =0; x<8; x++)
			printf("%02X ",key[x]);
 			printf("\n");
   			printf("\nUsando el mensaje: ");
   		for (x=0;x<16; x++)
        	printf("%02X ",msg[x]);
 			printf("\n");
	
	int y;
        rc4_init(key, 16);
    	    printf("\n");
		    printf("El cifrado es: ");
        for (y = 0; y < 16; y++)
            printf("%02X ", msg[y] ^ rc4_output());
            
	        printf("\n");
		    printf("\nEL State Final: ");
		for (x = 0; x < 16; x++)
       		printf("%02X ", S[x]);
			
	 
	int k;
	   rc4_init(key, 256);
	        printf("\n");
	   		printf("\nEL State Clave: ");
		for (k =0; k<256; k++)
	        printf("%02X ", S[k]); 	 
			printf("\n");
				
	int z;
	   rc4_init(key, 16);
            printf("\n");
            printf("El descifrado es: ");
        for (z = 0; z < 16; z++)
            printf("%02X ", decryp[z] ^ rc4_output());
            printf("\n");

/*	
	printf("\nEl cifrado es:\n");
        for (y = 0; y<16; y++)
        printf("%02X ", msg[y] ^ rc4_output());
        printf("\n");
*/	
	
return 0;
}
